// NotificationService.swift

import UserNotifications

class NotificationService {
    
    init() {
        Task {
            await requestPermission()
        }
    }
    
    func requestPermission() async {
        do {
            // Solicitar permisos b√°sicos (NO incluir .timeSensitive que est√° deprecated)
            let options: UNAuthorizationOptions = [.alert, .sound, .badge]
            let granted = try await UNUserNotificationCenter.current().requestAuthorization(options: options)
            print("‚úÖ Notification permission granted: \(granted)")
            
            if granted {
                // Verificar configuraci√≥n de notificaciones
                let settings = await UNUserNotificationCenter.current().notificationSettings()
                print("üîî Authorization status: \(settings.authorizationStatus.rawValue)")
                if #available(iOS 15.0, *) {
                    print("üîî Time Sensitive setting: \(settings.timeSensitiveSetting.rawValue)")
                }
            }
        } catch {
            print("‚ùå Error requesting notification permission: \(error)")
        }
    }
    
    // M√©todo actualizado para programar notificaciones time-sensitive
    func scheduleTimerCompletionNotification(for type: TimerType, in seconds: TimeInterval) async {
        // Verificar si las notificaciones est√°n habilitadas
        guard UserDefaults.standard.bool(forKey: Constants.UserDefaults.isNotificationEnabled) else {
            print("‚ùå Notifications disabled by user preference")
            return
        }
        
        // Verificar permisos del sistema
        let settings = await UNUserNotificationCenter.current().notificationSettings()
        guard settings.authorizationStatus == .authorized else {
            print("‚ùå No notification permissions")
            return
        }
        
        // IMPORTANTE: Cancelar TODAS las notificaciones pendientes para evitar duplicados
        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
        UNUserNotificationCenter.current().removeAllDeliveredNotifications()
        
        let content = UNMutableNotificationContent()
        content.title = String(localized: "¬°Tiempo completado!")
        
        // Configurar el mensaje seg√∫n el tipo de sesi√≥n
        switch type {
        case .work:
            content.body = String(localized: "Has completado una sesi√≥n de trabajo. ¬°Toma un descanso!")
            content.subtitle = "üçÖ Sesi√≥n de trabajo completada"
        case .shortBreak:
            content.body = String(localized: "El descanso ha terminado. ¬°Es hora de trabajar!")
            content.subtitle = "‚òï Descanso terminado"
        case .longBreak:
            content.body = String(localized: "El descanso largo ha terminado. ¬°Vamos a por otra ronda!")
            content.subtitle = "üåü Descanso largo completado"
        }
        
        // IMPORTANTE: Marcar la notificaci√≥n como Time Sensitive
        if #available(iOS 15.0, *) {
            content.interruptionLevel = .timeSensitive
            print("‚úÖ Setting interruption level to timeSensitive")
        }
        
        // Agregar relevance score para mayor prioridad
        if #available(iOS 15.0, *) {
            content.relevanceScore = 1.0
        }
        
        // Configurar sonido
        if UserDefaults.standard.bool(forKey: Constants.UserDefaults.isSoundEnabled) {
            // Usar un sonido m√°s prominente para time-sensitive
            content.sound = .defaultCritical
        }
        
        // Badge
        content.badge = 1
        
        // Agregar categor√≠a para acciones r√°pidas
        content.categoryIdentifier = "TIMER_COMPLETE"
        
        // Programar la notificaci√≥n
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: seconds, repeats: false)
        let request = UNNotificationRequest(
            identifier: "pomodoro-timer-completion",
            content: content,
            trigger: trigger
        )
        
        do {
            try await UNUserNotificationCenter.current().add(request)
            print("‚úÖ Scheduled time-sensitive notification for \(type.rawValue) in \(Int(seconds)) seconds")
        } catch {
            print("‚ùå Error scheduling notification: \(error)")
        }
    }
    
    // Configurar categor√≠as de notificaci√≥n con acciones
    func setupNotificationCategories() {
        let startWorkAction = UNNotificationAction(
            identifier: "START_WORK",
            title: "Iniciar trabajo",
            options: [.foreground]
        )
        
        let startBreakAction = UNNotificationAction(
            identifier: "START_BREAK",
            title: "Iniciar descanso",
            options: [.foreground]
        )
        
        let dismissAction = UNNotificationAction(
            identifier: "DISMISS",
            title: "Descartar",
            options: [.destructive]
        )
        
        let category = UNNotificationCategory(
            identifier: "TIMER_COMPLETE",
            actions: [startWorkAction, startBreakAction, dismissAction],
            intentIdentifiers: [],
            options: [.customDismissAction]
        )
        
        UNUserNotificationCenter.current().setNotificationCategories([category])
    }
    
    // Cancelar todas las notificaciones
    func cancelAllNotifications() {
        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
        UNUserNotificationCenter.current().removeAllDeliveredNotifications()
        UNUserNotificationCenter.current().setBadgeCount(0)
    }
}
